= TBC: Test by Convention =

== Conventions ==

Lines beginning with "exception_" are constants that when evaluated
throw an exception.

Lines beginning with "hunit_" are HUnit tests: TBC applies "runTestTT
. test" to them.

Lines beginning with "ok_" are constants that when evaluated do not
throw an exception.

Lines beginning "prop_" are QuickCheck tests: TBC applies "test" to them.

Lines beginning "test_" are boolean tests (of type Bool or IO Bool or
IO () with a print statement or ...): TBC runs them and expects the
final line of output to be "True".

Lines beginning "hunit_" are HUnit tests, or assertions, or lists of
assertions/tests.

Tests live in $PROJECT/Tests so test-specific hierarchical modules can
exist there.

The tests themselves must ensure the test framework (QuickCheck, etc.)
is in scope, i.e. be executable as they are in GHCi.

The 'tbc' executable will search upwards for a '.cabal' file and
assumes the 'dist/' directory is in the same place.

== Gotchas ==

Say:

runghc Setup test v

for a verbose session. FIXME we'd like to use '-v' but Cabal doesn't
pass it along.

There are no timeouts.

Don't compile TBC's Setup.hs or GHC will build it in the source dirs
(and not Cabal's dist/).

Conventions must retain the full name of the test, otherwise we run
into some nasty lexical issues, e.g. to avoid:

hunit_prop_blah =tName equals= prop_blah

- generalise Cabal support
 - currently assumes there's a single target (only tested for 'Library')
 - doesn't make sense to run all the tests for all targets
- include line number info
- Hugs/etc. support needs some love from someone who cares
- FFI/etc. support needs some love from someone who cares
 - there is some basic stuff there, we could scavenge more from cabal-test
- add flags
  - verbosity (use Cabal's flags / datatype)
  - run a particular test file / directory
- remove the concurrency in the GHCi driver if unnecessary
- add a Sanity convention
- add timeouts, restarting GHCi, several GHCi's.
  - really? how do we know how long tests should take?

Works now: allow it to use cabal-built objects from dist/build
... but: investigate the GHCi module header bug
 - leaving off "module T where" from the top of tests yields e.g.

not ok 13 - Tests/00_Circuits/022_xor_loop.hs:prop_correct
# <interactive>:1:5:
#     Can't find interface-file declaration for variable prop_correct
#       Probable cause: bug in .hi-boot file, or inconsistent .hi file
#       Use -ddump-if-trace to get an idea of which file caused the error
#     In the first argument of `test', namely `prop_correct'
#     In the expression: test prop_correct
#     In the definition of `it': it = test prop_correct

Figure out why this is so.

= TBC Design Desiderata =

== Nomenclature ==

"Test suite" is a tree, nodes are labelled by testgroups (directory tree)
"Testgroup" is a set of tests (guts of file)
A test is something that returns a TestResult.

"Sanity" tests the tests.

A TestFile is a compilable module, yielding a TestGroup or a TestSuite, as defined below.

Abstract type TestResult
 - skip, todo, success/failure, label, (include TestFile filename + line number)
 - and optionally an explanation (can package QC refutations here, or the SKIP/TODO stuff from TAP)
 - NB: provide HUnit interface at least

data TestResult = ok | fail | warn | ...

Abstract type TestSuiteResult
 - corresponds to directory structure, so recursive
 - leaves are TestResult
 - can render to TAP
 - can validate (isOK:: TestSuite

Desiderata

- implicit
- directory of tests in conventional place ($PROJECT/t)
- minimal boilerplate on individual test files
  - no requirement for module header (hierarchical module names screw us, tests can't be easily moved)
  - convention for "test_", "prop_" - run them as HUnit and QC props.
   - problem: if the user provides a type sig, we find the test twice.
  - if you define mainPlannedTestSuite :: (Plan Int, IO TestSuiteResult), we assume you need control and we'll run it and merge the TAP with other tests. (also mainTestSuite)
  - elsif you define mainTestGroup :: (Plan Int, IO TestGroupResult), we assume you need control and we'll run it and merge the TAP with other tests.
  - elsif you define main :: IO (), we'll treat it as a single test that's passed if it compiles and runs without an exception (?) -- quick and dirty.

- Test Classes, applying to test suites
 - climb TestSuite tree until we find TestClass.hs
 - contains vetTestSuite :: FilePath -> IO TestResult
   - provide recursive enumTests :: FilePath -> (FilePath -> IO a) -> IO a
 - this is really testing the test suite for various properties. more thought.

t/
000_sanity.hs
td/
 00_t
 01_t
 02_myCleverMainTSR.hs

000_sanity.hs:

t = sanity (\t -> grepTS "test_ && prop_" f)

sanity :: TestSuite -> IO TestResult
allTestsAreSane :: Test- > IO TestResult


CHECKED TO HERE

- consistent reporting of passing/failing tests. if we've written N tests, that should be reflected in the report, even if they're broken.
- graceful handling of uncompilable tests

- TAP compliant, so we can hook it into buildbot or whatever - no more NIH stuff

- ideally, relatively fast: this is not totally necessary, but loading every single testfile individually into ghci blows a bit.

- DONE handle being ^C'd - kill the slave process too.
- DONE HUnit support needs some love from someone who cares
